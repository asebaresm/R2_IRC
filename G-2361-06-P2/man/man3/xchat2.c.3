.TH "src/xchat2.c" 3 "Mon May 8 2017" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/xchat2.c \- 
.PP
Fichero con principalmente la implementación de los callbacks de xchat2\&.  

.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./includes/xchat2\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBcommand_query\fP (char *message)"
.br
.RI "\fIParsea los mensajes y respuestas que recibe del servidor\&. \fP"
.ti -1c
.RI "void \fBglueAndQuery\fP (char *command, char *\fBlast_command\fP)"
.br
.ti -1c
.RI "void \fBunpipe\fP (char *message, int MAXDATA_flag)"
.br
.RI "\fIFuncion para dividir en comandos la cadena 'message'\&. \fP"
.ti -1c
.RI "void \fBreceive_messages\fP (void *no_arg)"
.br
.RI "\fIFuncion ejecutada por un hilo, que recibe mensajes del servidor y los procesa segun el tipo de respuesta\&. \fP"
.ti -1c
.RI "void \fBIRCInterface_ActivateChannelKey\fP (char *channel, char *key)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivateExternalMessages\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivateInvite\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivateModerated\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivateNicksLimit\fP (char *channel, int limit)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivatePrivate\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivateProtectTopic\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_ActivateSecret\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_BanNick\fP (char *channel, char *nick)"
.br
.ti -1c
.RI "long \fBIRCInterface_Connect\fP (char *nick, char *user, char *realname, char *password, char *server, int port, boolean ssl)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateChannelKey\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateExternalMessages\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateInvite\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateModerated\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateNicksLimit\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivatePrivate\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateProtectTopic\fP (char *channel)"
.br
.ti -1c
.RI "void \fBIRCInterface_DeactivateSecret\fP (char *channel)"
.br
.ti -1c
.RI "boolean \fBIRCInterface_DisconnectServer\fP (char *server, int port)"
.br
.ti -1c
.RI "boolean \fBIRCInterface_ExitAudioChat\fP (char *nick)"
.br
.ti -1c
.RI "void \fBIRCInterface_GiveOp\fP (char *channel, char *nick)"
.br
.ti -1c
.RI "void \fBIRCInterface_GiveVoice\fP (char *channel, char *nick)"
.br
.ti -1c
.RI "void \fBIRCInterface_KickNick\fP (char *channel, char *nick)"
.br
.ti -1c
.RI "void \fBIRCInterface_NewCommandText\fP (char *command)"
.br
.ti -1c
.RI "void \fBIRCInterface_NewTopicEnter\fP (char *topicdata)"
.br
.ti -1c
.RI "boolean \fBIRCInterface_SendFile\fP (char *filename, char *nick, char *data, long unsigned int length)"
.br
.ti -1c
.RI "boolean \fBIRCInterface_StartAudioChat\fP (char *nick)"
.br
.ti -1c
.RI "boolean \fBIRCInterface_StopAudioChat\fP (char *nick)"
.br
.ti -1c
.RI "void \fBIRCInterface_TakeOp\fP (char *channel, char *nick)"
.br
.ti -1c
.RI "void \fBIRCInterface_TakeVoice\fP (char *channel, char *nick)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "pthread_mutex_t \fBloglock\fP"
.br
.RI "\fIDeclaracion del Mutex para el descriptor de fichero del log\&. Siempre tiene que ser definida en el source princpal\&. \fP"
.ti -1c
.RI "pthread_t \fBrecv_tid\fP"
.br
.ti -1c
.RI "pthread_t \fBsendf_tid\fP"
.br
.ti -1c
.RI "int \fBsockfd_user\fP = -1"
.br
.ti -1c
.RI "char \fBnick_user\fP [\fBMAXDATA\fP] = {0}"
.br
.ti -1c
.RI "char * \fBhostname\fP"
.br
.ti -1c
.RI "char * \fBactive_channel\fP = NULL"
.br
.ti -1c
.RI "char * \fBstream\fP"
.br
.ti -1c
.RI "char \fBhost_name\fP [128]"
.br
.ti -1c
.RI "char \fBlast_command\fP [256] = ''"
.br
.ti -1c
.RI "int \fBcheck_next_unpipe\fP = 0"
.br
.ti -1c
.RI "int \fBlast_test\fP = \fBOK\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Fichero con principalmente la implementación de los callbacks de xchat2\&. 


.PP
\fBAuthor:\fP
.RS 4
Alfonso Sebares 
.PP
Beatriz de Pablo 
.PP
Celia Mateos 
.RE
.PP
\fBDate:\fP
.RS 4
20/03/17 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "int command_query (char *message)"

.PP
Parsea los mensajes y respuestas que recibe del servidor\&. 
.PP
\fBParameters:\fP
.RS 4
\fImassage\fP mensaje recibido para procesar 
.RE
.PP
\fBReturns:\fP
.RS 4
OK si todo fue correcto y ERR si ocurrio un error 
.RE
.PP
< delimitador para separar mensajes 
.PP
.nf
40                                 {
41 
42         long ret = -1;
43         int retorno = -1;
44         char *prefix = NULL;
45         int n = -1;
46         int counter = 1;
47     char mensaje[MAXDATA] = {0};
48     char mensajeLargo[10*MAXDATA] = {0};
49     char *msg = NULL;
50     char *nick = NULL;
51     char *nick2 = NULL;
52     //002
53     char *servername = NULL;
54         char *versionname = NULL;
55         //003
56         char *timedate = NULL;
57         //004
58         char* version = NULL;
59         char* availableusermodes = NULL;
60         char* availablechannelmodes = NULL;
61         char* addedg = NULL;    
62         //251
63         int nusers = 0;
64         int ninvisibles = 0;
65         int nservers = 0;
66         char *type = NULL;
67         //char **parameters = NULL;
68         //int numparameters = 0;
69 
70         //265
71         char *substring = NULL;
72         //322
73         char *visible = NULL;
74         //332
75         char *topic = NULL;
76         char *channel = NULL;
77 
78         char inv[200];
79 
80         //353
81         //char* show_nick;
82 
83         //JOIN
84         char* key = NULL;       
85         char command[MAXDATA];
86 
87         //PRIVMSG
88         char* msgtarget = NULL;
89         char* origin_nick = NULL;
90         char nick_privmsg[MAXDATA];
91         char *filename = NULL, *hostname_destino = NULL;
92         unsigned long length, port;
93 
94         //PART
95         char* nick_part;
96         char* username_part;
97         char* host_part;
98         char* server_part;
99 
100         //PING
101         char* server, *server2;
102         char* command_pong;
103 
104         //Strtok
105         const char s[2] = ":"; 
106         char *token = NULL;
107 
108         //472
109         char *modechar = NULL;
110 
111         //MODE
112         char *channeluser = NULL;
113         char *mode = NULL;
114         char *user = NULL;
115 
116         //KICK
117         char *comment = NULL;
118 
119         //QUIT
120         char **channelsQuit;
121         int numChannelsQuit;
122         int i;
123         //char* realname, *host;
124 
125         //GENERAL
126         char **params;
127         int n_params;
128         int unknw_type;
129         const char space_delim[2] = " ";
130         char *message_cp = NULL;
131 
132         //g_print("Mesaje recibido en command_query: %s", message);
133 
134         /*
135         if(message == NULL) {
136                 g_print(RED "ERROR - In command_query: message == NULL al principio\n\n" RESET);
137                 return ERR;
138         }
139         */
140 
141         IRCInterface_PlaneRegisterInMessage(message);
142 
143         switch(IRC_CommandQuery(message)){
144                 case RPL_WELCOME: //001
145                         ret = IRCParse_RplWelcome(message, &prefix, &nick2, &msg);
146                         if(ret != IRC_OK){
147                                 g_print(RED "\nERROR - In command_query: case RPL_WELCOME - IRCParse_RplWelcome != IRC_OK" RESET);
148                                 //return IRCERR_NOCONNECT;
149                         }
150                         g_print("Comandos recibidos en el IRCParse_RplWelcome: \n");
151                         g_print("\t message: %s \n",message);
152                         g_print("\t prefix: %s \n",prefix);
153                         g_print("\t nick2: %s \n",nick2);
154                         g_print("\t msg: %s \n\n",msg);
155                         //obtenemos el hostname, util para el envio de ficheros
156                         hostname = strtok(msg, " ");
157                         while (((hostname = strtok(NULL, " ")) != NULL) && (counter < 5)){
158                                 counter++;
159                         }
160                         hostname = strtok(NULL, " ");
161                         g_print("\t hostname: %s \n\n", hostname);
162                         IRCInterface_WriteSystemThread_Pretty("*", msg);
163                         break;
164 
165                 case RPL_YOURHOST:      //002
166                         //long IRCParse_RplYourHost (char *strin, char **prefix, char **nick, char **msg, char **servername, char **versionname)
167                         ret = IRCParse_RplYourHost(message, &prefix, &nick2, &msg, &servername, &versionname);
168                         if(ret != IRC_OK){
169                                 g_print(RED "\nERROR - In command_query: case RPL_YOURHOST - IRCParse_RplYourHost != IRC_OK" RESET);
170                                 //return IRCERR_NOCONNECT;
171                         }
172                         g_print("Comandos recibidos en el IRCParse_RplYourHost: \n");
173                         g_print("\t message: %s \n",message);
174                         g_print("\t prefix: %s \n",prefix);
175                         g_print("\t nick2: %s \n",nick2);
176                         g_print("\t servername: %s \n",servername);
177                         g_print("\t versionname: %s \n",versionname);           
178                         g_print("\t msg: %s \n\n",msg);
179                         IRCInterface_WriteSystemThread_Pretty("*",msg);
180                         break;
181 
182                 case RPL_CREATED://003                  
183                         //long IRCParse_RplCreated (char *strin, char **prefix, char **nick,char **timedate, char **msg)
184                         ret = IRCParse_RplCreated(message, &prefix, &nick2, &timedate, &msg);
185                         if(ret != IRC_OK){
186                                 g_print(RED "\nERROR - In command_query: case RPL_CREATED - IRCParse_RplCreated != IRC_OK" RESET);
187                                 //return IRCERR_NOCONNECT;
188                         }
189                         g_print("Comandos recibidos en el IRCParse_RplCreated: \n");
190                         g_print("\t message: %s \n",message);
191                         g_print("\t prefix: %s \n",prefix);
192                         g_print("\t nick2: %s \n",nick2);
193                         g_print("\t timedate: %s \n",timedate); 
194                         g_print("\t msg: %s \n\n",msg);
195                         IRCInterface_WriteSystemThread_Pretty("*",msg);
196                         break;
197 
198                 case RPL_MYINFO: //004
199                         //long IRCParse_RplMyInfo (char *strin, char **prefix, char **nick, char **servername, char **version, char **availableusermodes, char **availablechannelmodes, char **addedg)
200                         ret = IRCParse_RplMyInfo(message, &prefix, &nick2, &servername, &version, &availableusermodes, &availablechannelmodes, &addedg);
201                         if(ret != IRC_OK){
202                                 g_print(RED "\nERROR - In command_query: case RPL_MYINFO - IRCParse_RplMyInfo != IRC_OK" RESET);
203                                 //return IRCERR_NOCONNECT;
204                         }
205                         g_print("Comandos recibidos en el IRCParse_RplMyInfo: \n");
206                         g_print("\t message: %s \n",message);
207                         g_print("\t prefix: %s \n",prefix);
208                         g_print("\t nick2: %s \n",nick2);
209                         g_print("\t servername: %s \n",servername);
210                         g_print("\t version: %s \n",version);
211                         g_print("\t availableusermodes: %s \n",availableusermodes);     
212                         g_print("\t availablechannelmodes: %s \n",availablechannelmodes);
213                         g_print("\t addedg: %s \n\n",addedg);
214                         n = snprintf(mensaje, sizeof mensaje,"%s %s %s %s %s ",servername,version,availableusermodes,availablechannelmodes,addedg);
215 
216                         if ( n < 0 || n >= sizeof mensaje ){
217                                 g_print("Error en sprintf \n");
218                         return ERR;    // or other error handling
219                         }
220                         IRCInterface_WriteSystemThread_Pretty("*",mensaje);             
221                         break;
222 
223                 case RPL_BOUNCE: //005
224                         //   long IRCParse_RplISupport (char *strin, char **prefix, char **nick, char **msg)                                            
225                         ret = IRCParse_RplISupport(message, &prefix, &nick2, &msg);
226                         if(ret != IRC_OK){
227                                 g_print(RED "\nERROR - In command_query: case RPL_BOUNCE -IRCParse_RplISupport != IRC_OK" RESET);
228                                 //return IRCERR_NOCONNECT;
229                         }
230                         g_print("Comandos recibidos en el IRCParse_RplISupport: \n");
231                         g_print("\t message: %s \n",message);
232                         g_print("\t prefix: %s \n",prefix);
233                         g_print("\t nick2: %s \n",nick2);
234                         g_print("\t msg: %s \n\n",msg);
235                         IRCInterface_WriteSystemThread_Pretty("*",msg);         
236                         break;
237 
238                 case RPL_LUSERCLIENT: //251
239                         //long IRCParse_RplLuserClient (char *strin, char **prefix, char **nick, char **msg, int *nusers, int *ninvisibles, int *nservers)
240                         
241                         ret = IRCParse_RplLuserClient(message, &prefix, &nick2, &msg, &nusers, &ninvisibles, &nservers);
242                         if(ret != IRC_OK){
243                                 //g_print(RED "\nERROR - In command_query: case RPL_LUSERCLIENT -IRCParse_RplLuserClient != IRC_OK" RESET);
244                                 //return IRCERR_NOCONNECT;
245                         }
246                         g_print("\t message: %s \n",message);
247                         g_print("\t prefix: %s \n",prefix);
248                         g_print("\t nick2: %s \n",nick2);
249                         g_print("\t msg: %s \n",msg);
250                         g_print("\t nusers: %d \n",nusers);
251                         g_print("\t ninvisibles: %d \n",ninvisibles);
252                         g_print("\t nservers: %d \n\n",nservers); 
253 
254                         /*ret_strstr = strstr(mensaje,"nicknick");
255                         IRCInterface_WriteSystem("*",ret_strstr);*/ 
256 
257                         sprintf(mensaje,"There are %d users and %d invisibles on %d servers ",nusers,ninvisibles,nservers);
258                         //sprintf(mensaje,"There are 13 users and 0 services on 1 servers");
259 
260                         IRCInterface_WriteSystemThread_Pretty("*",mensaje);                                                                                                     
261                         break;
262                         
263                 case RPL_LUSERCHANNELS: //254
264                         g_print("\t message: %s \n",message);
265                         /*Coger el primer token*/
266                         token = strtok(message,s);
267                         /*Ir por el resto*/
268                         if(token != NULL){
269                                 token = strtok(NULL,s); 
270                         }
271                         IRCInterface_WriteSystemThread_Pretty("*",token);
272 
273                         token = NULL;
274                         //IRCInterface_WriteSystem("*",message);        
275                         break;
276 
277                 case RPL_LUSERME : //255
278                         g_print("\t message: %s \n",message);
279                         /*Coger el primer token*/
280                         token = strtok(message,s);
281                         /*Ir por el resto*/
282                         if(token != NULL){
283                                 token = strtok(NULL,s); 
284                         }
285                         IRCInterface_WriteSystemThread_Pretty("*",token);
286 
287                         token = NULL;
288                         //IRCInterface_WriteSystem("*",message);        
289                         break;
290 
291                 case RPL_LOCALUSERS: //265
292                         substring = strnext(message, ':');
293                         if (substring){
294                                 substring = strnext(substring, ':');
295                         }
296                         IRCInterface_WriteSystemThread_Pretty("*",substring);
297 
298                         substring = NULL;
299                         break;
300 
301                 case RPL_GLOBALUSERS: //266
302                         g_print(GRN "\n>> [server command] RPL_GLOBALUSERS - message = %s\n" RESET, message);
303                         substring = strnext(message, ':');
304                         if (substring){
305                                 substring = strnext(substring, ':');
306                         }
307                         IRCInterface_WriteSystemThread_Pretty("*",substring);
308 
309                         substring = NULL;               
310                         break;
311 
312                 case RPL_LISTSTART: //321
313                         g_print(GRN "\n>> [server command] RPL_LISTSTART - message = %s\n" RESET, message);
314                         token = strtok(message,s);
315                         if(token != NULL){
316                                 token = strtok(NULL,s); 
317                         }
318                         IRCInterface_WriteSystemThread_Pretty("*",token);
319 
320                         break;
321 
322                 case RPL_LIST: //322
323                         //   long IRCParse_RplList (char *strin, char **prefix, char **nick, char **channel, char **visible, char **topic)
324                         g_print(GRN "\n>> [server command] RPL_LIST - message = %s\n" RESET, message);
325                         ret = IRCParse_RplList(message, &prefix, &nick2, &channel, &visible, &topic);
326                         if(ret != IRC_OK){
327                                 g_print(RED "\nERROR - In command_query: case RPL_LIST - IRCParse_RplList != IRC_OK" RESET);
328                                 //return IRCERR_NOCONNECT;
329                         }
330                         g_print("Comandos recibidos en el IRCParse_RplList: \n");
331                         g_print("\t message: %s \n",message);
332                         g_print("\t prefix: %s \n",prefix);
333                         g_print("\t nick2: %s \n",nick2);
334                         g_print("\t channel: %s \n",channel);
335                         g_print("\t visible: %s \n",visible);
336                         g_print("\t topic: %s \n\n",topic);
337 
338                         sprintf(mensajeLargo,"%s \t %s \t %s",channel,visible,topic);
339                         g_print("Mensaje creado: %s \n\n",mensajeLargo);
340 
341                         IRCInterface_WriteSystemThread_Pretty("*",mensajeLargo);
342                         mfree(5,prefix,nick2,channel,visible,topic);    
343                         break;
344 
345                 case RPL_LISTEND: //323
346                         g_print(GRN "\n>> [server command] RPL_LISTEND - message = %s\n" RESET, message);
347                         /*Coger el primer token*/
348                         token = strtok(message,s);
349                         /*Ir por el resto*/
350                         if(token != NULL){
351                                 token = strtok(NULL,s); 
352                         }
353                         IRCInterface_WriteSystemThread_Pretty("*",token);
354 
355                         token = NULL;
356                         //IRCInterface_WriteSystem("*",message);                        
357                         break;
358 
359                 case RPL_INVITING:
360                         g_print(GRN "\n>> [server command] RPL_INVITING - message = %s\n" RESET, message);
361 
362                         ret = IRCParse_RplInviting (message, &prefix , &nick, &channel, &msg);
363                         if(ret != IRC_OK){
364                                 g_print(RED "\nERROR - In command_query: case RPL_INVITING - IRCParse_RplInviting != IRC_OK" RESET);
365                                 break;
366                         }
367                         //strcpy("")
368                         if(strcmp(nick,nick_user) == 0){
369                                 strcpy(inv,"You invited ");
370                                 strcat(inv, channel);
371                                 strcat(inv, " to join ");
372                                 strcat(inv, msg);
373                                 IRCInterface_WriteSystemThread_Pretty("*",inv);
374                         }
375                         break;
376 
377                 case RPL_WHOREPLY: //352
378                         g_print(GRN "\n>> [server command] RPL_WHOREPLY - message = %s\n" RESET, message);
379                         break;
380 
381                 case RPL_MOTDSTART: //375
382                         g_print("\t message: %s \n",message);
383                         /*Coger el primer token*/
384                         token = strtok(message,s);
385                         /*Ir por el resto*/
386                         if(token != NULL){
387                                 token = strtok(NULL,s); 
388                         }
389                         IRCInterface_WriteSystemThread_Pretty("*",token);
390 
391                         token = NULL;
392                         //IRCInterface_WriteSystem("*",message);                        
393                         break;
394 
395                 case RPL_MOTD: //372
396                         g_print("\t message: %s \n",message);
397                         /*Coger el primer token*/
398                         token = strtok(message,s);
399                         /*Ir por el resto*/
400                         if(token != NULL){
401                                 token = strtok(NULL,s); 
402                         }
403                         IRCInterface_WriteSystemThread_Pretty("*",token);
404 
405                         token = NULL;
406                         //IRCInterface_WriteSystem("*",message);                
407                         break;
408 
409                 case RPL_ENDOFMOTD: //376
410                         g_print("\t message: %s \n",message);
411                         /*Coger el primer token*/
412                         token = strtok(message,s);
413                         /*Ir por el resto*/
414                         if(token != NULL){
415                                 token = strtok(NULL,s); 
416                         }
417                         IRCInterface_WriteSystemThread_Pretty("*",token);
418 
419                         token = NULL;
420                         //IRCInterface_WriteSystem("*",message);        
421                         return 19;//cambiar por un define
422                         break;
423 
424                 case RPL_TOPIC: //332
425                         g_print(GRN "\n>> [server command] RPL_TOPIC - message = %s\n" RESET, message);
426                         //g_print("\n=======CASE RPL_TOPIC=======\n");
427                         //IRCParse_RplTopic (char *strin, char **prefix, char **nick, char **nick2, char **channel, char **msg)
428                         ret = IRCParse_RplTopic(message, &prefix, &nick, &channel, &topic);
429                         if(ret != IRC_OK){
430                                 g_print(RED "ERROR - In command_query: case RPL_TOPIC - IRCParse_RplTopic devolvio != IRC_OK\n" RESET);
431                                 //return IRCERR_NOCONNECT;
432                         }
433                         g_print("\t message: %s \n",message);
434                         g_print("\t prefix: %s \n",prefix);
435                         g_print("\t nick: %s \n",nick);
436                         g_print("\t channel: %s \n",channel);
437                         g_print("\t topic: %s \n\n",topic);
438                         sprintf(mensaje,"El topic para %s es %s ",channel,topic);
439                         g_print("Mensaje: %s \n",mensaje);
440                         g_print("Existe canal: %d \n", IRCInterface_QueryChannelExistThread(channel));
441 
442                         IRCInterface_WriteChannelThread_Pretty(channel,"*",mensaje);    
443                         break;
444 
445                 case RPL_UNAWAY: //305
446                         g_print(GRN "\n>> [server command] RPL_UNAWAY - message = %s\n" RESET, message);
447                         IRCParse_RplUnaway (message, &prefix, &nick, &msg);
448                         IRCInterface_WriteSystemThread_Pretty("*",msg);
449                         break;
450 
451                 case RPL_AWAY: //306
452                         g_print(GRN "\n>> [server command] RPL_AWAY - message = %s\n" RESET, message);
453                         IRCParse_RplAway (message, &prefix, &nick, &nick2, &msg);
454                         IRCInterface_WriteSystemThread_Pretty("*",msg);
455                         break;
456 
457                 case TOPIC: //332
458                         g_print(GRN "\n>> [server command] TOPIC - message = %s\n" RESET, message);
459                         //   long IRCParse_Topic (char *strin, char **prefix, char **channel, char **topic)
460                         ret = IRCParse_Topic (message, &prefix, &channel, &topic);
461                         if(ret != IRC_OK){
462                                 g_print(RED "ERROR - In command_query: case TOPIC - IRCParse_Topic devolvio != IRC_OK\n" RESET);
463                                 return ERR;
464                         }
465 
466                         g_print("\t message: %s \n",message);
467                         g_print("\t prefix: %s \n",prefix);
468                         g_print("\t channel: %s \n",channel);
469                         g_print("\t topic: %s \n\n",topic);
470                         sprintf(mensaje,"El topic para %s es %s \n",channel,topic);
471                         g_print("Mensaje: %s \n",mensaje);
472                         g_print("Existe canal: %d \n", IRCInterface_QueryChannelExistThread(channel));
473 
474                         IRCInterface_WriteChannelThread_Pretty(channel,"*",mensaje);
475                         break;
476 
477                 case RPL_NOTOPIC:
478                         break;
479 
480                 case RPL_TOPICWHOTIME: //333
481                         break;  
482 
483                 case RPL_NAMREPLY: //353 - reply del servidor de de punames()
484                         g_print(GRN "\n>> [server command] RPL_NAMREPLY - message = %s\n" RESET, message);
485                         //long IRCParse_RplNamReply (char *strin, char **prefix, char **nick, char **type, char **channel, char **msg)
486                         ret = IRCParse_RplNamReply(message, &prefix, &nick, &type, &channel, &msg);
487                         if(ret != IRC_OK){
488                                 g_print(RED "ERROR - In command_query: case RPL_NAMREPLY - IRCParse_RplNamReply devolvio != IRC_OK\n" RESET);
489                                 //return IRCERR_NOCONNECT;
490                         }
491                         g_print("\t message: %s \n",message);
492                         g_print("\t prefix: %s \n",prefix);
493                         g_print("\t nick: %s \n",nick);
494                         g_print("\t type: %s \n",type);                                                         
495                         g_print("\t channel: %s \n",channel);
496                         g_print("\t msg: %s \n\n",msg);
497 
498                         //Ojo, que pasa si es names?? sin join
499                         //Añadir los nicks a la ventana de lad erecha\&. Pillarlos del WHO que se envía 
500                         //despues del join\&.
501                         //OJO es una prueba del funcionamineto de IRCInterface_AddNickChannel,
502                         //los nicks deberían de ser partidos mediante uso strtok o algo parecido
503                         //IRCInterface_AddNickChannel (channel, msg, msg, msg, msg, VOICE);
504                         //sprintf(mensaje,"Usuarios en %s: %s",channel,msg);
505                         //IRCInterface_WriteChannelThread(channel,"*",mensaje);
506                         interface_mostrar_nicks(channel,msg);   
507                         break;
508 
509                 case RPL_ENDOFNAMES: //366
510                         g_print("Mensaje recibido en RPL_ENDOFNAMES: \n");
511                         //long IRCParse_RplEndOfNames (char *strin, char **prefix, char **nick, char **channel, char **msg)
512                         ret = IRCParse_RplEndOfNames(message, &prefix, &nick2, &channel, &msg);
513                         if(ret != IRC_OK){
514                                 g_print(RED "ERROR - In command_query: case RPL_ENDOFNAMES - IRCParse_RplEndOfNames devolvio != IRC_OK\n" RESET);
515                                 //return IRCERR_NOCONNECT;
516                         }
517                         g_print("\t message: %s \n",message);
518                         g_print("\t prefix: %s \n",prefix);
519                         g_print("\t nick: %s \n",nick);                                                 
520                         g_print("\t channel: %s \n",channel);
521                         g_print("\t msg: %s \n\n",msg);
522 
523                         //IRCInterface_WriteChannelThread(channel,"*",msg);
524                         break;
525 
526                 case JOIN:
527                         g_print(GRN "\n>> [server command] JOIN - message = %s\n" RESET, message);
528                         //g_print(MAG "\nJOIN es %ld con IRC_CommandQuery\n" RESET, IRC_CommandQuery(message));
529                         //g_print(MAG "\nJOIN es %ld con IRCUser_CommandQuery\n" RESET, IRCUser_CommandQuery(message));
530 
531                         ret = IRCParse_Join (message, &prefix, &channel, &key, &msg);
532                         if(ret != IRC_OK){
533                                 g_print(RED "\nERROR - In command_query: JOIN - IRCParse_Join devolvio error\n" RESET);
534                                 return ERR;
535                         }
536                         g_print("Comandos recibidos en el IRCParse_Join: \n");
537                         g_print("\t message: %s \n",message);
538                         g_print("\t prefix: %s \n",prefix);
539                         g_print("\t channel: %s \n",channel);
540                         g_print("\t key: %s \n",key);
541                         g_print("\t msg: %s \n\n",msg);
542 
543                         IRCInterface_AddNewChannelThread(msg, 0);
544                         IRCParse_ComplexUser(prefix, &nick_part, &username_part, &host_part, &server_part);
545                         sprintf(mensaje, "%s (%s) se ha unido al canal", nick_part, prefix);
546                         if(!strcmp(nick_user, nick_part)){
547                                 IRCInterface_WriteChannelThread(msg,"*", "Bienvenido al canal");
548                         } else {
549                                 IRCInterface_WriteChannelThread(msg,"*", mensaje);
550                         }
551                         //Actualizar al lista de usuarios
552                         sprintf(mensaje,"/names %s",msg);
553                         retorno = punames(mensaje);
554                         if(retorno == ERR){
555                                 g_print("ERROR - JOIN - punames");
556                                 return ERR;                             
557                         }
558                         break;
559 
560                 case NAMES:
561                         g_print(GRN "\n>> [server command] NAMES - message = %s\n" RESET, message);
562                         g_print(GRN "\nNo hay nada aquí, revisar (?)" RESET);
563                         break;
564 
565                 case PRIVMSG:
566                         g_print(GRN "\n>> [server command] PRIVMSG - message = %s\n" RESET, message);
567                         ret = IRCParse_Privmsg(message, &prefix, &msgtarget, &msg);
568                         if(ret != IRC_OK){
569                                 g_print(RED "\nERROR - In command_query: IRCParse_Privmsg devolvio != IRC_OK" RESET);
570                                 return ERR;
571                         }
572 
573                         if ((origin_nick = strtok(prefix, "!")) != NULL){
574                                 strcpy(nick_privmsg, origin_nick);
575                         }
576                         g_print("\t nick_privmsg: %s \n",nick_privmsg);
577                         g_print("\t prefix: %s \n",prefix);
578                         g_print("\t msgtarget: %s \n",msgtarget);
579                         g_print("\t msg: %s \n\n",msg);
580 
581                         if(msg[0] == 1 || (msg[0] == ':' || msg[1] == 1)) { //envio de ficheros
582                                 g_print("alguien quiere enviarme un fichero\n");
583                                 
584                                 filename = strtok(msg, " ");
585                                 filename = strtok(NULL, " ");
586                                 hostname_destino = strtok(NULL, " ");
587                                 port = (unsigned long) atol(strtok(NULL, " "));
588                                 length = (unsigned long) atol(strtok(NULL, " "));
589                                 g_print("filename: %s \n",filename);
590                                 g_print("hostname_destino: %s \n",hostname_destino);
591                                 g_print("length: %ld \n",length);
592                                 g_print("port: %ld \n",port);
593 
594                                 if(IRCInterface_ReceiveDialogThread(nick_user, filename) == TRUE){
595                                         g_print("Lanzamos el hilo que guarda el archivo\n");
596                                         //pthread_t tid;
597 
598                                         File_args args;
599                                         args\&.hostname = hostname_destino;
600                                         args\&.filename = filename;
601                                         args\&.port = port;
602                                         args\&.length = length;
603 
604                                         if(pthread_create( &sendf_tid, NULL, (void*) save_file, (void*) &args) < 0){
605                                         g_print("Error en la llamada a save_file\n");
606                                                 return ERR;
607                                         }
608                                         break;
609                                 }
610                                 /*
611                                 if (sscanf(msg, "\001AUDIOCHAT %ms %li", &hostname_destino, &port) > 0) {
612                                         g_print("host=%s, port=%li\n", hostname_destino, port);
613                                 } else{
614                                         g_print("Formato incorrecto en envio de fichero\n");
615                                 }*/
616                                 ret = enviarDatos(sockfd_user, command, strlen(command));
617                                 if(ret < 0){
618                                         g_print(RED "ERROR - In command_query: case PRIVMSG - enviarDatos() devolvio error (ver secuencia en \&.log)\n\t\tEl cliente se cerrará\&.\n" RESET);
619                                         exit(1);
620                                 }
621                                 if(ret == 0){ //timeout 
622                                         g_print(RED "ERROR - In command_query: case PRIVMSG - enviarDatos() mandó 0 Bytes(ver secuencia en \&.log)\n\t\t(Timeout de conexión probablemente)\n" RESET);
623                                         exit(1);
624                                 }
625                         }
626 
627                         if(msgtarget[0] != '#'){//no grupo
628                                 IRCInterface_AddNewChannelThread(nick_privmsg, 0);                              
629                                 IRCInterface_WriteChannelThread_Pretty(nick_privmsg, nick_privmsg, msg);
630                                 return OK;
631                         }
632 
633                         //IRCInterface_WriteChannelThread(msgtarget, nick_privmsg, msg);
634                         IRCInterface_WriteChannelThread_Pretty(msgtarget, nick_privmsg, msg);
635                         break;
636 
637                 case PART:
638                         g_print(GRN "\n>> [server command] PART - message = %s\n" RESET, message);
639                         ret = IRCParse_Part (message, &prefix, &channel, &msg);
640                         if(ret != IRC_OK){
641                                 g_print(RED "\nERROR - In command_query: case PART - IRCParse_Part devolvio != IRC_OK" RESET);
642                                 return ERR;
643                         }
644                         g_print("Comandos recibidos en el IRCParse_PART: \n");
645                         g_print("\t message: %s \n",message);
646                         g_print("\t prefix: %s \n",prefix);
647                         g_print("\t channel: %s \n",channel);
648                         g_print("\t msg: %s \n\n",msg);
649 
650                         IRCParse_ComplexUser(prefix, &nick_part, &username_part, &host_part, &server_part);
651                         IRCInterface_DeleteNickChannelThread(channel, nick_part);
652                         sprintf(mensaje, "El usuario %s ha salido del grupo (%s)",nick_part, msg);
653                         IRCInterface_WriteChannelThread_Pretty(channel,"*",mensaje);
654                         if(strcmp(nick_user, nick_part) == 0){
655                                 IRCInterface_RemoveChannelThread(channel);
656                         } else {
657                                 sprintf(mensaje,"/names %s",channel);
658                                 retorno = punames(mensaje);
659                                 if(retorno == ERR){
660                                         g_print("ERROR - JOIN - punames");
661                                         return ERR;                             
662                                 }
663                         }
664 
665                         break;
666 
667                 case NOTICE:
668                         //g_print("\n=======CASE NOTICE=======\n");
669                         g_print(GRN "\n>> [server command] NOTICE - message = %s\n" RESET, message);
670 
671                         IRCParse_Notice(message, &prefix, &msgtarget, &msg);
672 
673                         g_print("prefix = %s\n", prefix);
674                         g_print("msgtarget = %s\n", msgtarget);
675                         g_print("msg = %s\n", msg);
676                         
677 
678                         //break;
679                         //caso: NOTICE !(generado por el server) (triggeado por /HELP, p\&.ej\&.)
680                         //caso: !(:irc\&.eps\&.net NOTICE testame2 :example "HELP quit" or "HELP privmsg"\&.)
681 
682                         if(msg == NULL || msgtarget == NULL || prefix == NULL){
683                                 IRCInterface_WriteSystemThread_Pretty("*","");
684                                 break;
685                         }
686 
687                         if((!strcmp(msgtarget, nick_user)) && (strcmp(prefix,"irc\&.eps\&.net") != 0)) {
688                                 IRCParse_ComplexUser(prefix, &nick_part, &username_part, &host_part, &server_part);                             
689                                 sprintf(mensaje, ">%s<", nick_part);
690                                 IRCInterface_AddNewChannelThread(nick_part, 0);
691                                 IRCInterface_WriteChannelThread (nick_part,mensaje,msg);
692                         } else if(msgtarget[0] == '#'){
693                                 IRCParse_ComplexUser(prefix, &nick_part, &username_part, &host_part, &server_part);
694                                 sprintf(mensaje, ">%s/%s<", nick_part, msgtarget);
695                                 IRCInterface_AddNewChannelThread(msgtarget, 0);
696                                 IRCInterface_WriteChannelThread (msgtarget,mensaje,msg);
697                         } else {//AUTH, /HELP
698                                 //g_print(RED "\n>>>>>>>>>> NO BOI\n" RESET);
699                                 IRCInterface_WriteSystemThread_Pretty("*",msg);
700                         }
701                         //IRCInterface_WriteSystemThread("*",msg);
702                         break;
703 
704                 case PING:
705                         g_print(GRN "\n>> [server command] PING - message = %s\n" RESET, message);
706                         //:irc\&.eps\&.net PONG irc\&.eps\&.net :LAG1460877705692323
707                         IRCParse_Ping (message, &prefix, &server, &server2, &msg);
708                         g_print("\t prefix: %s \n",prefix);
709                         g_print("\t server: %s \n",server);
710                         g_print("\t server2: %s \n",server2);
711                         g_print("\t msg: %s \n\n",msg);
712                         IRCMsg_Pong(&command_pong, prefix?prefix:hostname, server?server:"", server2?server2:"", msg?msg:"");
713                         enviarDatos(sockfd_user, command_pong, strlen(command_pong));
714                         g_print(GRN "Pong enviado\n" RESET);
715                         IRCInterface_PlaneRegisterOutMessageThread(command_pong);
716                         break;
717 
718                 case KICK:
719                         g_print(GRN "\n>> [server command] KICK - message = %s\n" RESET, message);
720                         //long IRCParse_Kick (char *strin, char **prefix, char **channel, char **user, char **comment)
721 
722                         ret = IRCParse_Kick(message, &prefix, &channel, &user, &comment);
723                         if(ret != IRC_OK){
724                                 g_print(RED "\nERROR - In command_query: case KICK - IRCParse_Kick devolvio != IRC_OK" RESET);
725                                 return ERR;
726                         }
727                         g_print("\t message: %s \n",message);
728                         g_print("\t prefix: %s \n",prefix);
729                         g_print("\t channel: %s \n",channel);
730                         g_print("\t user: %s \n",user);
731                         g_print("\t comment: %s \n\n",comment);
732 
733                         sprintf(mensaje,"%s Ha sido echado de %s con mensaje/motivo(%s)",user, channel, comment);
734                         
735                         g_print("Mensaje: %s \n",mensaje);
736                         IRCInterface_WriteChannelThread_Pretty(channel,"*",mensaje);
737 
738                         //Actualizar al lista de usuarios
739                         IRCInterface_DeleteNickChannelThread (channel, user);
740                         if(!strcmp(nick_user,user)){
741                                 IRCInterface_RemoveChannelThread(channel);
742                         }
743                         /*memset(mensaje,0,MAXDATA);
744                         sprintf(mensaje,"/names %s",channel);
745                         retorno = punames(mensaje);
746                         if(retorno == ERR){
747                                 g_print("ERROR - MODE - punames");
748                                 return ERR;                             
749                         } */
750                         break;
751 
752                 case ERR_UNKNOWNMODE: //472
753                         g_print(GRN "\n>> [server command] ERR_UNKNOWNMODE - message = %s\n" RESET, message);
754                         //      long IRCParse_ErrUnknownMode (char *strin, char **prefix, char **nick, char **modechar, char **channel, char **msg)
755                         ret = IRCParse_ErrUnknownMode(message, &prefix, &nick, &modechar, &channel, &msg);
756                         if(ret != IRC_OK){
757                                 g_print(RED "\nERROR - In command_query: case ERR_UNKNOWNMODE - IRCParse_ErrUnknownMode != IRC_OK" RESET);
758                                 //return -1;
759                         }
760                         g_print("Comandos recibidos en el IRCParse_ErrUnknownMode: \n");
761                         g_print("\t message: %s \n",message);
762                         g_print("\t prefix: %s \n",prefix);
763                         g_print("\t nick: %s \n",nick);
764                         g_print("\t modechar: %s \n",nick);                                             
765                         g_print("\t channel: %s \n",channel);
766                         g_print("\t msg: %s \n\n",msg);         
767 
768                         sprintf(mensaje,"%s %s\n",channel,msg);
769                         IRCInterface_WriteChannelThread_Pretty(channel,"*",mensaje);
770                         break;
771 
772                 case MODE: //
773                         g_print(GRN "\n>> [server command] MODE - message = %s\n" RESET, message);
774                         //    long IRCParse_Mode (char *strin, char **prefix, char **channeluser, char **mode, char **user)
775                         ret = IRCParse_Mode(message, &prefix, &channeluser, &mode, &user);
776                         if(ret != IRC_OK){
777                                 g_print(RED "\nERROR - In command_query: case MODE - IRCParse_Mode != IRC_OK" RESET);
778                                 return ERR;
779                         }
780                         g_print("\t message: %s \n",message);
781                         g_print("\t prefix: %s \n",prefix);
782                         g_print("\t channeluser: %s \n",channeluser);
783                         g_print("\t mode: %s \n",mode);
784                         g_print("\t user: %s \n\n",user);
785 
786                         nick = strtok(prefix,"!"); //Coger el usuario que ha mandando el mode
787                         if(user != NULL){ //Modo usuario
788                                 //Comprobar si es k o l 
789                                 if(strcasecmp(mode,"+k") == 0){
790                                         sprintf(mensaje,"%s establece contraseña del canal %s como: %s ",nick, channeluser, user);
791                                         g_print("Mensaje: %s \n",mensaje);
792                                         IRCInterface_WriteChannelThread_Pretty(channeluser,"*",mensaje);
793                                         break;          
794                                 }else if(strcasecmp(mode,"+l") == 0){
795                                         sprintf(mensaje,"%s establece límite del canal %s a %s usuarios",nick, channeluser, user);
796                                         g_print("Mensaje: %s \n",mensaje);
797                                         IRCInterface_WriteChannelThread_Pretty(channeluser,"*",mensaje);
798                                         break;                                          
799                                 }
800 
801                                 sprintf(mensaje,"%s establece el modo %s al usuario %s en el canal %s ",nick, mode, user, channeluser);
802                                 g_print("Mensaje: %s \n",mensaje);
803                                 IRCInterface_WriteChannelThread_Pretty(channeluser,"*",mensaje);
804 
805                                 /* No funciona IRCInterface_ChangeNickStateChannel :(
806                                 if(strcasecmp(mode,"+o") == 0){
807                                         g_print("modo op\n");
808                                         IRCInterface_ChangeNickStateChannel (channeluser, nick, OPERATOR);
809                                 }else if(strcasecmp(mode,"+v") == 0){
810                                         g_print("modo voice\n");
811                                         IRCInterface_ChangeNickStateChannel (channeluser, nick, VOICE);
812                                 }else{
813                                         g_print("else otro modo\n");*/
814                                         //Actualizar al lista de usuarios
815                                         
816                                         memset(mensaje,0,MAXDATA);
817                                         sprintf(mensaje,"/names %s",channeluser);
818                                         retorno = punames(mensaje);
819                                         if(retorno == ERR){
820                                                 g_print("ERROR - MODE - punames");
821                                                 return ERR;                             
822                                         }                                       
823                                 //}                             
824                         }else{
825                                 sprintf(mensaje,"%s establece modo %s %s ", nick, channeluser, mode);
826                                 g_print("Mensaje: %s \n",mensaje);
827                                 IRCInterface_WriteChannelThread_Pretty(channeluser,"*",mensaje);
828                         }                       
829                         break;
830 
831                 case INVITE:                    
832                         g_print(GRN "\n>> [server command] INVITE - message = %s\n" RESET, message);
833                         IRCInterface_WriteSystemThread_Pretty("*",message);
834                         break;
835 
836                 case NICK:
837                         g_print(GRN "\n>> [server command] NICK - message = %s\n" RESET, message);
838 
839                         IRCParse_Nick (message, &prefix, &nick, &msg);
840                         IRCParse_ComplexUser(prefix, &nick_part, &username_part, &host_part, &server_part);
841                         g_print("\t message: %s \n",message);
842                         g_print("\t prefix: %s \n",prefix);
843                         g_print("\t nick: %s \n",nick); //esta a null
844                         g_print("\t msg: %s \n",msg); //el nick viene aqui
845                         IRCInterface_ChangeNickThread(nick_part, msg);
846                         sprintf(mensaje, "%s ahora es conocido como %s", nick_part, msg);
847                         if(!strcmp(nick_part, nick_user)){
848                                 strcpy(nick_user,msg);                  
849                         }
850                         IRCInterface_WriteSystemThread_Pretty("*",mensaje);     
851                         g_print("new nick: %s\n", msg);
852 
853                         break;
854 
855                 case QUIT:
856                         /*
857                         * Enfoque 1: Cuando alguien sale (QUIT del servidor)
858                         *       Obtener la lista de canales abiertos -> '/names' en cada canal -> Capturar reply del servidor:
859                         *       353 -> interface_mostrar_nicks(channel,msg); (se actualizan todas las listas de chats abiertos)
860                         *
861                         */
862                         g_print(GRN "\n>> [server command] QUIT - message = %s\n" RESET, message);
863                         
864                         IRCParse_Quit (message, &prefix, &msg);
865                         IRCParse_ComplexUser(prefix, &nick_part, &username_part, &host_part, &server_part);
866                         g_print("\t message: %s \n",message);
867                         g_print("\t prefix: %s \n",prefix);
868                         g_print("\t msg: %s \n",msg);
869                         sprintf(mensaje, "%s se ha desconectado (%s)", nick_part, msg);
870                         IRCInterface_WriteSystemThread("*",mensaje);
871 
872                         IRCInterface_ListAllChannelsThread(&channelsQuit, &numChannelsQuit);
873 
874                         for(i=0; i<numChannelsQuit; i++){
875                                 sprintf(mensaje,"/names %s",channelsQuit[i]);
876                                 retorno = punames(mensaje);
877                                 if(retorno == ERR){
878                                         g_print("ERROR - JOIN - punames");
879                                         return ERR;                             
880                                 }
881                         }
882                         break;
883 
884                 case RPL_CHANNELMODEIS: //324   
885                         g_print(GRN "\n>> [server command] RPL_CHANNELMODEIS - message = %s\n" RESET, message);
886                         //long IRCParse_RplChannelModeIs(char *strin, char **prefix, char **nick, char **channel, char **modetxt)
887                         /*ret = IRCParse_RplChannelModeIs(message, &prefix, &channeluser, &mode, &user);
888                         if(ret != IRC_OK){
889                                 g_print("ERROR: IRCInterface_Connect - IRCParse_RplTopic\n");
890                                 return ERR;
891                         }
892                         g_print("\t message: %s \n",message);
893                         g_print("\t prefix: %s \n",prefix);
894                         g_print("\t channeluser: %s \n",channeluser);
895                         g_print("\t mode: %s \n",mode);
896                         g_print("\t user: %s \n\n",user);
897 
898                         sprintf(mensaje,"%s establece modo %s %s ", user, channeluser, mode);
899                         
900                         g_print("Mensaje: %s \n",mensaje);
901                         IRCInterface_WriteChannelThread(channeluser,"*",mensaje);*/
902 
903                         //Actualizar al lista de usuarios
904                         break;  
905 
906                 case ERR_CHANOPRIVSNEEDED: //482
907                         g_print(GRN "\n>> [server command] ERR_CHANOPRIVSNEEDED - message = %s\n" RESET, message);
908                         //   long IRCParse_ErrChanOPrivsNeeded (char *strin, char **prefix, char **nick, char **channel, char **msg)
909                         ret = IRCParse_ErrChanOPrivsNeeded(message, &prefix, &nick, &channel, &msg);
910                         if(ret != IRC_OK){
911                                 g_print(RED "\nERROR - In command_query: case ERR_CHANOPRIVSNEEDED - IRCParse_ErrChanOPrivsNeeded != IRC_OK" RESET);
912                                 //return ERR;
913                         }
914                         g_print("Comandos recibidos en el IRCParse_ErrChanOPrivsNeeded: \n");
915                         g_print("\t message: %s \n",message);
916                         g_print("\t prefix: %s \n",prefix);
917                         g_print("\t nick: %s \n",nick);                 
918                         g_print("\t channel: %s \n",channel);
919                         g_print("\t msg: %s \n\n",msg);         
920 
921                         sprintf(mensaje,"%s %s\n",channel,msg);
922                         IRCInterface_WriteChannelThread_Pretty(channel,"*",mensaje);
923                         break;
924 
925                 case ERR_NOSUCHSERVER:
926                         g_print(GRN "\n>> [server command] ERR_NOSUCHSERVER - message = %s\n" RESET, message);
927                         IRCInterface_WriteSystemThread_Pretty("*",message);
928                         break;
929 
930                 /*TRATAMIENTO DE ERRORES*/
931                 case IRCERR_NOCOMMAND:
932                         g_print(RED "\nERROR - In command_query: Mensaje de error recibido en switch():\n\tIRCERR_NOCOMMAND -  no hay ningún comando en la cadena de caracteres\n" RESET);
933                         IRCInterface_WriteSystemThread_Pretty("*",message);
934                         return ERR;
935 
936                 case IRCERR_NOPARAMS:
937                         g_print(RED "\nERROR - In command_query: Mensaje de error recibido en switch():\n\tIRCERR_NOPARAMS -  se ha introducido una cadena de caracteres nula\n" RESET);
938                         IRCInterface_WriteSystemThread("*",message);
939                         return ERR;
940 
941                 case IRCERR_UNKNOWNCOMMAND:
942                         //g_print(MAG"\n>>>>>>>>>>>>>>>>>>>>>>>>>>\n"RESET);
943                         //ret =  IRCParse_GeneralCommand (message, &prefix, &type, &params, &n_params, &msg);
944                         /*Intenta hacer un parseo apra un type no soportado por IRC_CommandQuery()*/
945                         unknw_type = parse_type(message);
946                         if(unknw_type != ERR){
947                                 switch(unknw_type){ //Intentar tratar un mensaje no reconocido por IRC_CommandQuery() 
948                                         case 250:
949                                                 g_print(GRN "\n>> [server command] unknw_type = 250 - message = %s\n" RESET, message);
950                                                 substring = strnext(message, ':');
951                                                 if (substring){
952                                                         substring = strnext(substring, ':');
953                                                 }
954                                                 IRCInterface_WriteSystemThread_Pretty("*",substring);
955 
956                                                 substring = NULL;
957                                         break;
958 
959                                         default:
960                                         g_print(YEL "WARN - In command_query: case IRCERR_UNKNOWNCOMMAND:\n\tNo se ha definido un tratamiento para un mensaje desconocido con type = %d\n" RESET, unknw_type);
961                                         IRCInterface_WriteSystemThread("*",message);
962                                         break;
963                                 }
964                                 return OK;
965                         }
966 
967                         g_print(YEL "WARN - In command_query: Mensaje de error recibido en switch():\n\tIRCERR_UNKNOWNCOMMAND -  l comando que contiene no es reconocido por esta función\&.\n" RESET);
968                         IRCInterface_WriteSystemThread("*",message);
969                         return OK;
970 
971                 default:
972                         switch(parse_type2(message)){
973                                 case 306: //parche porque no devuelve 306 para AWAY
974                                         g_print(GRN "\n>> [server command] 306 (RPL_AWAY) - message = %s\n" RESET, message);
975                                         //IRCParse_RplAway (message, &prefix, &nick, &nick2, &msg);
976                                         IRCInterface_WriteSystemThread_Pretty("*",strnext(strnext(message, ':'), ':'));
977                                         return OK;
978                                 case 311: //WHOIS
979                                 case 312:
980                                 case 319:
981                                 case 317:
982                                 case 318:
983                                         g_print(GRN "\n>> [server command] 311-318 (RPL_WHOIS\&.\&.\&.) - message = %s\n" RESET, message);
984                                         IRCInterface_WriteSystemThread_Pretty("*",strnext(strnext(message, ':'), ':'));
985                                         return OK;
986                                 default:
987                                         break;
988                         }
989                         g_print(YEL "WARN - In command_query: Alcanzado default del switch()(TO_DO):\n\t %s\n" RESET, message);
990                         //sprintf(aux,"[%s] %s",gmtime(time(NULL)), nick)
991                         IRCInterface_WriteSystemThread("*",message);
992                         return OK;
993         }
994 
995         //Liberamos memoria
996         //mfree(33,msg,nick,nick2,servername,versionname,timedate,version,availableusermodes,availablechannelmodes,addedg,type,visible,topic,channel,key,
997         //msgtarget,origin_nick,filename,hostname_destino,nick_part,username_part,host_part,server_part,server,server2,command_pong,token,modechar,channeluser,
998         //mode,user,comment,realname,host);
999         return OK;
1000 
1001 }
.fi
.SS "void glueAndQuery (char *command, char *last_command)"

.PP
.nf
1003                                                     {
1004         char* glued_command = (char*) malloc((2 + strlen(command) + strlen(last_command)) * sizeof(char));
1005         
1006         strcpy(glued_command, last_command);
1007         strcat(glued_command, command);
1008 
1009         g_print(BLU "\nglued_command = %s\n" RESET, glued_command);
1010         command_query(glued_command);
1011 
1012         free(command);
1013         free(glued_command);
1014 }
.fi
.SS "void IRCInterface_ActivateChannelKey (char *channel, char *key)"

.PP
.nf
1222 {
1223         char modo[MAXDATA] = {0};
1224 
1225         g_print(BLU "\nIRCInterface_ActivateChannelKey(char *channel, char *key) call\n" RESET);
1226 
1227         sprintf(modo,"+k %s",key);
1228         if (changeMode(channel, NULL, modo) != OK)
1229                 g_print(RED "ERROR - In IRCInterface_ActivateChannelKey: Error en changeMode, devolvió ERR\n" RESET);
1230 }
.fi
.SS "void IRCInterface_ActivateExternalMessages (char *channel)"

.PP
.nf
1263 {
1264         g_print(BLU "\nIRCInterface_ActivateExternalMessages(char *channel) call\n" RESET);
1265         if (changeMode(channel, NULL, "+n") != OK)
1266                 g_print(RED "ERROR - In IRCInterface_ActivateExternalMessages: Error en changeMode, devolvió ERR\n" RESET);
1267 }
.fi
.SS "void IRCInterface_ActivateInvite (char *channel)"

.PP
.nf
1300 {
1301         g_print(BLU "\nIRCInterface_ActivateInvite(char *channel) call\n" RESET);
1302         if (changeMode(channel, NULL, "+i") != OK)
1303                 g_print(RED "ERROR - In IRCInterface_ActivateInvite: Error en changeMode, devolvió ERR\n" RESET);
1304 }
.fi
.SS "void IRCInterface_ActivateModerated (char *channel)"

.PP
.nf
1337 {
1338         g_print(BLU "\nIRCInterface_ActivateModerated(char *channel) call\n" RESET);
1339 
1340         if (changeMode(channel, NULL, "+m") != OK)
1341                 g_print(RED "ERROR - In IRCInterface_ActivateModerated: Error en changeMode, devolvió ERR\n" RESET);
1342 }
.fi
.SS "void IRCInterface_ActivateNicksLimit (char *channel, intlimit)"

.PP
.nf
1378 {
1379         char mode[MAXDATA] = {0};
1380 
1381         g_print(BLU "\nIRCInterface_ActivateNicksLimit(char *channel, int limit) call\n" RESET);
1382 
1383         sprintf(mode,"+l %d",limit);
1384         if (changeMode(channel, NULL, mode) != OK)
1385                 g_print(RED "ERROR - In IRCInterface_ActivateNicksLimit: Error en changeMode, devolvió ERR\n" RESET);
1386 }
.fi
.SS "void IRCInterface_ActivatePrivate (char *channel)"

.PP
.nf
1419 {
1420         g_print(BLU "\nIRCInterface_ActivatePrivate(char *channel) call\n" RESET);
1421         if (changeMode(channel, NULL, "+p") != OK)
1422                 g_print(RED "ERROR - In IRCInterface_ActivatePrivate: Error en changeMode, devolvió ERR\n" RESET);
1423 }
.fi
.SS "void IRCInterface_ActivateProtectTopic (char *channel)"

.PP
.nf
1456 {
1457         g_print(BLU "\nIRCInterface_ActivateProtectTopic(char *channel) call\n" RESET);
1458         if (changeMode(channel, NULL, "+t") != OK)
1459                 g_print(RED "ERROR - In IRCInterface_ActivateProtectTopic: Error en changeMode, devolvió ERR\n" RESET);
1460 }
.fi
.SS "void IRCInterface_ActivateSecret (char *channel)"

.PP
.nf
1493 {
1494         g_print(BLU "\nIRCInterface_ActivateSecret(char *channel) call\n" RESET);
1495 
1496         if (changeMode(channel, NULL, "+s") != OK)
1497                 g_print(RED "ERROR - In IRCInterface_ActivateSecret: Error en changeMode, devolvió ERR\n" RESET);
1498 }
.fi
.SS "void IRCInterface_BanNick (char *channel, char *nick)"

.PP
.nf
1533 {
1534         g_print(BLU "\nIRCInterface_BanNick(char *channel, char *nick) call\n" RESET);
1535 
1536         if (changeMode(channel, nick, "+b") != OK)
1537                 g_print(RED "ERROR - In IRCInterface_BanNick: Error en changeMode, devolvió ERR\n" RESET);
1538 }
.fi
.SS "long IRCInterface_Connect (char *nick, char *user, char *realname, char *password, char *server, intport, booleanssl)"

.PP
.nf
1585 {
1586         int optval = 1;
1587         long ret = -1;
1588         int retorno = -1;
1589         char *command = NULL;
1590         char *prefix = NULL;
1591         int sockfd = -1;
1592 
1593         struct hostent *he;
1594     struct in_addr **addr_list;
1595     int i=0;
1596     char ip_addr[INET_ADDRSTRLEN] = {0};
1597 
1598     char *msgNick = NULL;
1599     char mode[MAXDATA] = {0};
1600 
1601         g_print("IRCInterface_Connect - Datos introducidos por el usuario \n");
1602         g_print("\t nick: %s \n",nick);
1603         g_print("\t user: %s \n",user);
1604         g_print("\t realname: %s \n",realname);
1605         g_print("\t password: %s \n",password);
1606         g_print("\t server: %s \n",server);
1607         g_print("\t port: %d \n",port);
1608         g_print("\t ssl: %d \n",ssl);
1609 
1610     if ((he = gethostbyname(server)) == NULL) {  // get the host info
1611         g_print(RED "ERROR - In IRCInterface_Connect: gethostbyname() devol NULL\n" RESET);
1612         return IRCERR_NOCONNECT;
1613     }
1614 
1615     // print information about this host:
1616     g_print("Official name is: %s\n", he->h_name);
1617     g_print("    IP addresses: ");
1618 
1619     addr_list = (struct in_addr **)he->h_addr_list;
1620     for(i = 0; addr_list[i] != NULL; i++) {
1621         strcat(ip_addr,inet_ntoa(*addr_list[i]));
1622         g_print("%s ", inet_ntoa(*addr_list[i]));
1623     }
1624     g_print("\n");
1625     g_print("ip_addr: %s \n",ip_addr);
1626 
1627     struct sockaddr_in server_struct;
1628 
1629     /*Socket*/
1630     sockfd = socket(AF_INET,SOCK_STREAM,0/*TCP*/);
1631     if (sockfd == -1){
1632         g_print(RED "ERROR - In IRCInterface_Connect: Error creando socket, devolvió < 0\n" RESET);
1633         return IRCERR_NOCONNECT;
1634     }
1635 
1636     optval = 1;
1637     setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&optval , sizeof(int)); //reutilizar socket sucesivas ejecuciones
1638 
1639     memset(&server_struct, '0', sizeof(server_struct)); 
1640     server_struct\&.sin_family = AF_INET;
1641     server_struct\&.sin_port = htons(port); 
1642     memset(&(server_struct\&.sin_zero), '\0', 8);
1643     server_struct\&.sin_addr = **addr_list; 
1644 
1645     /*Connect*/
1646     if (connect(sockfd, (struct sockaddr*)&server_struct, sizeof(server_struct)) < 0){
1647         g_print(RED "ERROR - In IRCInterface_Connect: Error en connect(), devolivó < 0\n" RESET);
1648         return IRCERR_NOCONNECT;
1649     }
1650 
1651         //Conectarse al socket
1652         //sockfd = clienteConexionTCP(ip_addr,port);
1653         if(sockfd == -1){
1654                 g_print(RED "ERROR - In IRCInterface_Connect: sockfd == -1\n" RESET);
1655                 return IRCERR_NOCONNECT;
1656         }else{
1657                 g_print(GRN "Conexión establecida con host: %s y puerto: %d \n" RESET, server, port);
1658         }
1659 
1660         //Copiar los parametros a las variables globales
1661         strcpy(host_name, he->h_name);
1662     strcpy(nick_user,nick);
1663     sockfd_user = sockfd;
1664 
1665         if(ssl == FALSE){
1666                 g_print(GRN "Lanzamos el hilo que recibe mensajes\n" RESET);
1667                 if((ret = pthread_create( &recv_tid, NULL, (void*) receive_messages, (void*) "no_arg")) != 0){
1668                 g_print(RED "ERROR - In IRCInterface_Connect: pthread_create() devolvio != 0, error = %d\n" RESET, (int)ret);
1669                 //logERR("pthread_detach() devolvio error");
1670                         return ERR;
1671                 }
1672 
1673                 if (pthread_detach(recv_tid) != OK){
1674                         g_print(RED "ERROR - In IRCInterface_Connect: pthread_detach() devolvio error\n" RESET);
1675                          //logERR("pthread_detach() devolvio error");
1676                          return ERR;
1677                 }
1678                 //sleep(5);
1679                 //Prueba CAP
1680                 /*
1681                 retorno = enviarDatos(sockfd, "CAP LS 302", strlen("CAP LS 302")+1);
1682                 if(retorno <= 0){
1683                         g_print(RED "ERROR - In IRCInterface_Connect: enviarDatos() envió %d Bytes - NICK\n" RESET, retorno);
1684                         return IRCERR_NOCONNECT;
1685                 }
1686                 IRCInterface_PlaneRegisterOutMessage(command);
1687                 */
1688 
1689                 //Enviar pass si existe
1690                 if((password != NULL) && (strlen(password) > 0)){ //Comprobar si hay password
1691                         //Enviar mensaje al servidor con la pass
1692                         ret = IRCMsg_Pass (&command, prefix, password);
1693                         if(ret != IRC_OK){
1694                                 g_print(RED "ERROR - In IRCInterface_Connect: IRCMsg_Pass devolvio IRCERR_NOPASSWORD: No se ha introducido una clave\&.\n" RESET);
1695                                 return IRCERR_NOCONNECT;
1696                         }
1697                         g_print("IRCMsg_Pass: %s",command);
1698                         retorno = enviarDatos(sockfd, command, strlen(command));
1699                         if(retorno <= 0){
1700                                 g_print(RED "ERROR - In IRCInterface_Connect: enviarDatos() envió %d Bytes - PASS\n" RESET, retorno);
1701                                 return IRCERR_NOCONNECT;
1702                         }
1703                         IRCInterface_PlaneRegisterOutMessage(command); //Mandar a registro plano
1704                         free(command);          
1705 
1706                 }
1707 
1708                 //Enviar mensaje con el nick
1709                 command = NULL;
1710                 ret = IRCMsg_Nick (&command, prefix, nick, msgNick);
1711                 
1712                 if(ret != IRC_OK){
1713                         g_print(RED "ERROR - In IRCInterface_Connect: IRCMsg_Nick() devolvio codigo de error\n" RESET);
1714                         return IRCERR_NOCONNECT;
1715                 }
1716                 g_print("IRCMsg_Nick: %s",command);
1717 
1718                 retorno = enviarDatos(sockfd, command, strlen(command));
1719                 //retorno = enviarDatos(sockfd, "NICK test_\r\n\0", strlen("NICK test_\r\n\0")+1);
1720                 if(retorno <= 0){
1721                         g_print(RED "ERROR - In IRCInterface_Connect: enviarDatos() envió %d Bytes - NICK\n" RESET, retorno);
1722                         return IRCERR_NOCONNECT;
1723                 }
1724                 IRCInterface_PlaneRegisterOutMessage(command);
1725                 free(command);
1726                 
1727                 //mode
1728                 //Enviar mensaje con el user
1729                 strcpy(mode,"0");
1730                 command = NULL;
1731 
1732                 ret = IRCMsg_User (&command, prefix, user, mode , realname);
1733                 if(ret != IRC_OK){
1734                         g_print(RED "ERROR - In IRCInterface_Connect: IRCMsg_User() devolvio codigo de error\n" RESET);
1735                         return IRCERR_NOCONNECT;
1736                 }
1737                 g_print("IRCMsg_User: %s",command);
1738 
1739                 retorno = enviarDatos(sockfd, command, strlen(command));
1740                 //retorno = enviarDatos(sockfd, "USER test_ 0 * :test_\r\n\0", strlen("USER test_ 0 * :test_\r\n\0")+1);
1741                 if(retorno <= 0){
1742                         g_print(RED "ERROR - In IRCInterface_Connect: enviarDatos() envió %d Bytes - USER\n" RESET, retorno);
1743                         return IRCERR_NOCONNECT;
1744                 }
1745                 IRCInterface_PlaneRegisterOutMessage(command);
1746                 free(command);
1747                 
1748         }else{ //Fin del if de ssl = false
1749                 return IRCERR_NOSSL;
1750         }
1751 
1752         return IRC_OK;
1753 }
.fi
.SS "void IRCInterface_DeactivateChannelKey (char *channel)"

.PP
.nf
1787 {
1788         g_print(BLU "\nIRCInterface_DeactivateChannelKey(char *channel) call\n" RESET);
1789 
1790         if (changeMode(channel, NULL, "-k") != OK)
1791                 g_print(RED "ERROR - In IRCInterface_DeactivateChannelKey: Error en changeMode, devolvió ERR\n" RESET);
1792 }
.fi
.SS "void IRCInterface_DeactivateExternalMessages (char *channel)"

.PP
.nf
1825 {
1826         g_print(BLU "\nIRCInterface_DeactivateExternalMessages(char *channel) call\n" RESET);
1827 
1828         if (changeMode(channel, NULL, "-n") != OK)
1829                 g_print(RED "ERROR - In IRCInterface_DeactivateExternalMessages: Error en changeMode, devolvió ERR\n" RESET);
1830 }
.fi
.SS "void IRCInterface_DeactivateInvite (char *channel)"

.PP
.nf
1863 {
1864         g_print(BLU "\nIRCInterface_DeactivateInvite(char *channel) call\n" RESET);
1865 
1866         if (changeMode(channel, NULL, "-i") != OK)
1867                 g_print(RED "ERROR - In IRCInterface_DeactivateInvite: Error en changeMode, devolvió ERR\n" RESET);
1868 }
.fi
.SS "void IRCInterface_DeactivateModerated (char *channel)"

.PP
.nf
1901 {
1902         g_print(BLU "\nIRCInterface_DeactivateModerated(char *channel) call\n" RESET);
1903 
1904         if (changeMode(channel, NULL, "-m") != OK)
1905                 g_print(RED "ERROR - In IRCInterface_DeactivateModerated: Error en changeMode, devolvió ERR\n" RESET);
1906 }
.fi
.SS "void IRCInterface_DeactivateNicksLimit (char *channel)"

.PP
.nf
1939 {
1940         g_print(BLU "\nIRCInterface_DeactivateNicksLimit(char *channel) call\n" RESET);
1941 
1942         if (changeMode(channel, NULL, "-l") != OK)
1943                 g_print(RED "ERROR - In IRCInterface_DeactivateNicksLimit: Error en changeMode, devolvió ERR\n" RESET);
1944 }
.fi
.SS "void IRCInterface_DeactivatePrivate (char *channel)"

.PP
.nf
1979 {
1980         g_print(BLU "\nIRCInterface_DeactivatePrivate(char *channel) call\n" RESET);
1981 
1982         if (changeMode(channel, NULL, "-p") != OK)
1983                 g_print(RED "ERROR - In IRCInterface_DeactivatePrivate: Error en changeMode, devolvió ERR\n" RESET);
1984 }
.fi
.SS "void IRCInterface_DeactivateProtectTopic (char *channel)"

.PP
.nf
2017 {
2018         g_print(BLU "\nIRCInterface_DeactivateProtectTopic(char *channel) call\n" RESET);
2019 
2020         if (changeMode(channel, NULL, "-t") != OK)
2021                 g_print(RED "ERROR - In IRCInterface_DeactivateProtectTopic: Error en changeMode, devolvió ERR\n" RESET);
2022 }
.fi
.SS "void IRCInterface_DeactivateSecret (char *channel)"

.PP
.nf
2055 {
2056         g_print(BLU "\nIRCInterface_DeactivateSecret(char *channel) call\n" RESET);
2057 
2058         if (changeMode(channel, NULL, "-s") != OK)
2059                 g_print(RED "ERROR - In IRCInterface_DeactivateSecret: Error en changeMode, devolvió ERR\n" RESET);
2060 }
.fi
.SS "boolean IRCInterface_DisconnectServer (char *server, intport)"

.PP
.nf
2097 {
2098         g_print(BLU "\nIRCInterface_DisconnectServer(char *server, int port) call\n" RESET);
2099 
2100         puquit(NULL);
2101 
2102         return TRUE;
2103 }
.fi
.SS "boolean IRCInterface_ExitAudioChat (char *nick)"

.PP
.nf
2141 {
2142         g_print(BLU "\nIRCInterface_ExitAudioChat(char *nick) call\n" RESET);
2143         return TRUE;
2144 }
.fi
.SS "void IRCInterface_GiveOp (char *channel, char *nick)"

.PP
.nf
2179 {
2180         g_print(BLU "\nIRCInterface_GiveOp(char *channel, char *nick) call\n" RESET);
2181 
2182         if (changeMode(channel, nick, "+o") != OK)
2183                 g_print(RED "ERROR - In IRCInterface_GiveOp: Error en changeMode, devolvió ERR\n" RESET);
2184 }
.fi
.SS "void IRCInterface_GiveVoice (char *channel, char *nick)"

.PP
.nf
2219 {
2220         g_print(BLU "\nIRCInterface_GiveVoice(char *channel, char *nick) call\n" RESET);
2221 
2222         if (changeMode(channel, nick, "+v") != OK)
2223                 g_print(RED "ERROR - In IRCInterface_GiveOp: Error en changeMode, devolvió ERR\n" RESET);
2224 }
.fi
.SS "void IRCInterface_KickNick (char *channel, char *nick)"

.PP
.nf
2259 {
2260         g_print(BLU "\nIRCInterface_KickNick(char *channel, char *nick) call\n" RESET);
2261 
2262         int ret = -1;
2263         char *command=NULL;
2264 
2265         //long IRCMsg_Kick (char **command, char *prefix, char * channel, char *user, char *comment)
2266         ret = IRCMsg_Kick (&command, NULL, channel, nick, "Te han echado del canal\&.");
2267         if(ret != IRC_OK){
2268                 g_print(RED "ERROR - In IRCInterface_KickNick : Error en IRCMsg_Kick, no devolvio IRC_OK\n" RESET);
2269                 return;
2270         }
2271         ret = enviarDatos(sockfd_user, command, strlen(command));
2272         if(ret == ERR){
2273                 g_print(RED "ERROR - In IRCInterface_KickNick: enviarDatos devolvio ERR\n" RESET);
2274                 return;
2275         }
2276         IRCInterface_PlaneRegisterOutMessage(command);
2277         free(command);  
2278 }
.fi
.SS "void IRCInterface_NewCommandText (char *command)"

.PP
.nf
2313 {
2314         g_print(BLU "\n[callback] IRCInterface_NewCommandText(char *command) call\n" RESET);
2315 
2316         int num_comando = -1, ret;
2317         char *comando = NULL;
2318         char *prefix = NULL;
2319         //pthread_t tid;
2320         //IRCInterface_PlaneRegisterInMessage(command);
2321         //IRCInterface_WriteSystem(nick_user, command);
2322 
2323         if(command[0] != '/'){//mensaje a grupo o nick directamente
2324                 active_channel = IRCInterface_ActiveChannelName();
2325                 g_print("Active_channel: %s\n", active_channel);
2326 
2327                 //   long IRCMsg_Privmsg (char **command, char *prefix, char * msgtarget, char *msg)
2328                 ret = IRCMsg_Privmsg (&comando, prefix, active_channel, command);
2329                 if(ret == ERR){
2330                         g_print(RED "ERROR - In IRCInterface_NewCommandText: IRCMsg_Privmsg devolvio error\n" RESET);
2331                         return;
2332                 }
2333                 g_print("\t Mensaje a enviar IRCMsg_Privmsg: %s \n",comando);
2334 
2335                 ret = enviarDatos(sockfd_user,comando, strlen(comando));
2336                 if(ret < 0){
2337                         g_print(RED "ERROR - In IRCInterface_NewCommandText: enviarDatos() devolvio error (ver secuencia en \&.log)\n\t\tEl cliente se cerrará\&.\n" RESET);
2338                         exit(1);
2339                 }
2340                 if(ret == 0){ //timeout 
2341                         g_print(RED "ERROR - In IRCInterface_NewCommandText: enviarDatos() mandó 0 Bytes(ver secuencia en \&.log)\n\t\t(Timeout de conexión probablemente)\n" RESET);
2342                         exit(1);
2343                 }
2344                 IRCInterface_PlaneRegisterOutMessage(comando);
2345                 //No recibimos nada en este comando, los mensajes de otros usuarios los recibimos por otro hilo
2346                 IRCInterface_WriteChannel(active_channel, nick_user, command);
2347                 return;
2348         }
2349 
2350         num_comando = IRCUser_CommandQuery (command);   
2351         g_print(MAG "\n\t>num_comando -> array de funciones: %d \n" RESET,num_comando);
2352         if (num_comando > 56){
2353                 g_print(YEL "\nWARN - Comando de usuario no reconocido/no tiene asignado una funcion en el array\&.\n" RESET);
2354                 pdefault(command);
2355                 return;
2356         }
2357         if (p_array_funciones[num_comando](command) == -1){
2358                 g_print(RED "ERROR - In IRCInterface_NewCommandText: Error en p_array_funciones num: %d \n" RESET,num_comando);
2359         }
2360 }
.fi
.SS "void IRCInterface_NewTopicEnter (char *topicdata)"

.PP
.nf
2394 {
2395         g_print(BLU "\nIRCInterface_NewTopicEnter(char *topicdata) call\n" RESET);
2396 
2397         int ret = -1;
2398         char *command=NULL;
2399 
2400         //long IRCMsg_Topic (char **command, char *prefix, char * channel, char *topic)
2401         active_channel = IRCInterface_ActiveChannelName();
2402         ret = IRCMsg_Topic (&command, NULL, active_channel, topicdata);
2403         if(ret != IRC_OK){
2404                 g_print(RED "ERROR - In IRCInterface_NewTopicEnter: IRCMsg_Topic no devolvio IRC_OK\n" RESET);
2405                 return;
2406         }
2407         ret = enviarDatos(sockfd_user, command, strlen(command));
2408         if(ret == ERR){
2409                 g_print(RED "ERROR - In IRCInterface_NewTopicEnter: enviarDatos devolvio ERR\n" RESET);
2410                 return;
2411         }
2412         IRCInterface_PlaneRegisterOutMessage(command);
2413         free(command);  
2414 }
.fi
.SS "boolean IRCInterface_SendFile (char *filename, char *nick, char *data, long unsigned intlength)"

.PP
.nf
2456 {
2457         g_print(BLU "\nIRCInterface_SendFile(char *filename, char *nick, char *data, long unsigned int length) call\n" RESET);
2458         return TRUE;
2459 }
.fi
.SS "boolean IRCInterface_StartAudioChat (char *nick)"

.PP
.nf
2498 {
2499         g_print(BLU "\nIRCInterface_StartAudioChat(char *nick) call\n" RESET);
2500         return TRUE;
2501 }
.fi
.SS "boolean IRCInterface_StopAudioChat (char *nick)"

.PP
.nf
2539 {
2540         g_print(BLU "\nIRCInterface_StopAudioChat(char *nick) call\n" RESET);
2541         return TRUE;
2542 }
.fi
.SS "void IRCInterface_TakeOp (char *channel, char *nick)"

.PP
.nf
2577 {
2578         g_print(BLU "\nIRCInterface_TakeOp(char *channel, char *nick) call\n" RESET);
2579 
2580         if (changeMode(channel, nick, "-o") != OK)
2581                 g_print(RED "ERROR - In IRCInterface_TakeOp: Error en changeMode, devolvió ERR\n" RESET);
2582 }
.fi
.SS "void IRCInterface_TakeVoice (char *channel, char *nick)"

.PP
.nf
2617 {
2618         g_print(BLU "\nIRCInterface_TakeVoice(char *channel, char *nick) call\n" RESET);
2619 
2620         if (changeMode(channel, nick, "-v") != OK)
2621                 g_print(RED "ERROR - In IRCInterface_TakeVoice: Error en changeMode, devolvió ERR\n" RESET);    
2622 }
.fi
.SS "int main (intargc, char *argv[])"
MMMMMMMMMM MMMMM AAAAAAA IIIIIII NNNNNNNNNN NNNNNN MMMMMMMMMM MMMMM AAAAAAAA IIIII NNNNNNNNNN NNNN MMMMM MMMM MM MM AAAAA AA III NNNNN NNNN NN MMMMM MMMM MM MM AAAAA AA III NNNNN NNNN NN MMMMM MMMM MM MM AAAAA AA III NNNNN NNNN NN MMMMM MMMM MM MM AAAAA AA III NNNNN NNNN NN MMMMM MMMM MM MM AAAAA AA III NNNNN NNNN NN MMMMM MMMM MM MM AAAAAAAAAAAAAA III NNNNN NNNN NN MMMMM MMMMM MM AAAAA AA III NNNNN NNNN NN MMMMM MMM MM AAAAA AA III NNNNN NNNN NN MMMMM MM AAAAA AA III NNNNN NNNN NN MMMMM MM AAAAA AA III NNNNN NNNN NN MMMMMMM MMMM AAAAAA AAAA IIIII NNNNNN NNNNNNN MMMMMMMMM MMMMMM AAAAAAAA AAAAAA IIIIIII NNNNNNN NNNNNNN 
.PP
.nf
2647 {
2648         FILE* log_fp = NULL;
2649 
2650         //init de las funciones de log
2651         log_fp = initLog();
2652         if (log_fp == NULL){
2653                 perror("error en initLog()");
2654                 return EXIT_FAILURE;
2655         }
2656 
2657         if (pthread_mutex_init(&loglock, NULL) != OK){
2658                 perror("\n mutex init ha devuelto error\n");
2659                 return EXIT_FAILURE;
2660         }
2661 
2662         /* La función IRCInterface_Run debe ser llamada al final      */
2663         /* del main y es la que activa el interfaz gráfico quedándose */
2664         /* en esta función hasta que se pulsa alguna salida del       */
2665         /* interfaz gráfico\&.                                          */
2666         IRCInterface_Run(argc, argv);
2667 
2668         pthread_mutex_destroy(&loglock);
2669 
2670         return 0;
2671 }
.fi
.SS "void receive_messages (void *no_arg)"

.PP
Funcion ejecutada por un hilo, que recibe mensajes del servidor y los procesa segun el tipo de respuesta\&. 
.PP
\fBParameters:\fP
.RS 4
\fIno_arg\fP estructura de parametros (vacia) 
.RE
.PP
\fBReturns:\fP
.RS 4
OK si todo es correcto, ERR si se produce un error 
.RE
.PP

.PP
.nf
1134                                    {
1135 
1136         char message[MAXDATA];
1137         int ret;
1138         g_print(GRN "Hilo Preparado para recibir mensajes\n" RESET);
1139 
1140         int oldtype;
1141         /*No es necesario el pthread_cancel asíncrono aparentemente
1142         * +INFO: https://www\&.securecoding\&.cert\&.org/confluence/display/c/POS44-C\&.+Do+not+use+signals+to+terminate+threads
1143         *                https://www\&.securecoding\&.cert\&.org/confluence/display/c/POS47-C\&.+Do+not+use+threads+that+can+be+canceled+asynchronously
1144         */
1145         //pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);
1146         
1147         while(1){
1148                 //printf(BLU "\nwhile en receive_messages\n" RESET);
1149                 //sem_wait(&recepcionTCP);
1150                 memset(message, 0, sizeof(message));
1151                 ret = recvDatos(sockfd_user, message, MAXDATA, host_name);
1152                 //sem_post(&recepcionTCP);
1153                 if(ret == ERR){
1154                         g_print(RED "ERROR - In receive_messages: recvDatos() devolvio error (ver \&.log)\n\t\tEl cliente se cerrará\&.\n" RESET);
1155                         exit(1);
1156                 }
1157                 if(ret == 0){ //timeout seguramente
1158                         g_print(RED "ERROR - In receive_messages: recvDatos() leyó 0 Bytes(ver \&.log)\n\t\t(Timeout)El cliente se cerrará\&.\n" RESET);
1159                         exit(1);
1160                 }
1161                 if(ret == MAXDATA)
1162                         unpipe(message, 1);
1163                 else
1164                         unpipe(message, 0);
1165         }
1166 }
.fi
.SS "void unpipe (char *message, intMAXDATA_flag)"

.PP
Funcion para dividir en comandos la cadena 'message'\&. 
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP cadena recibida, puede incluir mas de un comando 
.br
\fIMAXDATA_flag\fP flag que marca que se ha leído el maximo del buffer y han podido cortarse comandos 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.PP
.nf
1022                                             {
1023 
1024         char *q = message, *command;
1025         char *glued_command = NULL;
1026         int i = 0, test = 0;
1027 
1028         while (q != NULL){
1029                 q = IRC_UnPipelineCommands(q, &command);
1030                 test = testIRC_CommandQuery(command);
1031 
1032                 if(MAXDATA_flag == 1){  //caso 1\&.)riesgo: se ha llamado a unpipe() con un bloque de tam MAXDATA
1033                         if((i == 0) && (check_next_unpipe == 1)){       //caso 2\&.1)primera iter unpipe, no MAXDATA PERO 'check\&.\&.\&.' activado
1034                                 if(test == OK && last_test == ERR){                     //caso 2\&.1\&.1)además no da error
1035                                         glueAndQuery(command, last_command);
1036                                 }else if(test == ERR && last_test == OK){       //caso 2\&.1\&.2)o bien es la segunda mitad del comando o bien
1037                                                                                                                         //           da la casualidad de que es un comando mal formado independiente
1038                                         glueAndQuery(command, last_command);
1039                                 }else if(test == ERR && last_test == ERR){      //caso 2\&.1\&.3)ambos test petan\&. Concatenar y rezar
1040                                         glued_command =  (char*) malloc((2 + strlen(command) + strlen(last_command)) * sizeof(char));
1041                                         strcpy(glued_command, last_command);
1042                                         strcat(glued_command, command);
1043 
1044                                         g_print(BLU "\nglued_command = %s\n" RESET, glued_command);
1045                                         if (testIRC_CommandQuery(glued_command) == OK){
1046                                                 command_query(glued_command);
1047                                                 free(glued_command);
1048                                         }else{
1049                                                 command_query(last_command);
1050                                                 command_query(command);
1051                                         }
1052 
1053                                         free(command);
1054                                 }else{                                                                          //caso 2\&.1\&.4)ambos comandos están bien formados
1055                                         command_query(command);
1056                                         free(command);
1057                                 }
1058                                 //resetear flags:
1059                                 check_next_unpipe = 0;
1060                                 strcpy(last_command, "0");
1061 
1062                         }else if(q == NULL){ //q es 'resto', comprobar que sea el último comando parseado del bloque
1063                                 if (test == ERR){                                                       //caso 1\&.1)error en test con MAXDATA_f
1064                                         g_print(YEL "\nWARN - In unpipe: testIRC_CommandQuery(command) devolvio ERR con MAXDATA_flag activada\n\tSe almacena el trozo de comando=%s\n" RESET, command);
1065                                         last_test = ERR;
1066                                         strcpy(last_command, command);
1067                                         free(command);
1068                                         check_next_unpipe = 1;
1069                                         break; //(!) en principio no tiene sentido seguir iterando, es el último mensaje (trozo) del bloque
1070                                 }else{                                                                          //caso 1\&.2)no error en test con MAXDATA_f, 2 posibilidades:
1071                                                                                                                         //a)justo ha cogido el comando entero, b)ha cogido parte del comando y lo reconoce como valido
1072                                         g_print(YEL "\nWARN - In unpipe: testIRC_CommandQuery(command) devolvio OK con MAXDATA_flag activada\n\tSe almacena el trozo de comando=%s\n" RESET, command);
1073                                         last_test = OK;
1074                                         strcpy(last_command, command);
1075                                         free(command);
1076                                 }
1077                                 check_next_unpipe = 1;
1078                         }else{          //si no es el último comando parseado, command_query normal
1079                                 if(command_query(command) == ERR){
1080                                         g_print(RED "ERROR - In unpipe: command_query() devolvio ERR (MAXDATA_flag == 1 pero no es el último comando)\n\tcommand = %s" RESET, command);
1081                                         free(command);
1082                                 }
1083                         }
1084 
1085                 }else{                                  //caso 2)no se ha llamado a unpipe() con un bloque de tam MAXDATA
1086                         if((i == 0) && (check_next_unpipe == 1)){       //caso 2\&.1)primera iter unpipe, no MAXDATA PERO 'check\&.\&.\&.' activado
1087                                 if(test == OK && last_test == ERR){                     //caso 2\&.1\&.1)además no da error
1088                                         glueAndQuery(command, last_command);
1089                                 }else if(test == ERR && last_test == OK){       //caso 2\&.1\&.2)o bien es la segunda mitad del comando o bien
1090                                                                                                                         //           da la casualidad de que es un comando mal formado independiente
1091                                         glueAndQuery(command, last_command);
1092                                 }else if(test == ERR && last_test == ERR){      //caso 2\&.1\&.3)ambos test petan\&. No se puede concatenar
1093                                         glued_command =  (char*) malloc((2 + strlen(command) + strlen(last_command)) * sizeof(char));
1094                                         strcpy(glued_command, last_command);
1095                                         strcat(glued_command, command);
1096                                         g_print(BLU "\nglued_command = %s\n" RESET, glued_command);
1097 
1098                                         if (testIRC_CommandQuery(glued_command) == OK){
1099                                                 command_query(glued_command);
1100                                                 free(glued_command);
1101                                         }else{
1102                                                 command_query(last_command);
1103                                                 command_query(command);
1104                                         }
1105 
1106                                         free(command);
1107                                 }else{                                                                          //caso 2\&.1\&.4)ambos comandos están bien formados
1108                                         command_query(command);
1109                                         free(command);
1110                                 }
1111                                 //resetear flags:
1112                                 check_next_unpipe = 0;
1113                                 strcpy(last_command, "0");
1114                         }else{                                                                          //caso 2\&.2)no MAXDATA, no i=0: command_query normal
1115                                 if(command_query(command) == ERR){
1116                                         g_print(RED "ERROR - In unpipe: command_query() devolvio ERR (i != 0, check_\&.\&.\&. False, MAXDATA_flag False)\n\tcommand = %s" RESET, command);
1117                                         free(command);
1118                                 }
1119                         }
1120                 }
1121                 i++;
1122         }
1123 
1124     if(command == NULL){
1125         g_print(RED "ERROR - In unpipe: Se ha solicitado buscar un comando en una cadena vacia\n\n" RESET);
1126     }   
1127 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char* active_channel = NULL"
nombre del ultimo canal activo en la itnerfaz 
.SS "int check_next_unpipe = 0"
FLAG: 0 no check, 1 check 
.SS "char host_name[128]"
aux con el hostname, uso en libreria TCP 
.SS "char* hostname"
hostname del servidor (uso auxiliar) 
.SS "char last_command[256] = ''"
almacena el ultimo 'message' pasado a \fBunpipe()\fP 
.SS "int last_test = \fBOK\fP"
FLAG: 0 OK, -1 ERR 
.SS "pthread_mutex_t loglock"

.PP
Declaracion del Mutex para el descriptor de fichero del log\&. Siempre tiene que ser definida en el source princpal\&. mutex para el descriptor del log de la ejecución actual 
.SS "char nick_user[\fBMAXDATA\fP] = {0}"
nick del usuario operador del cliente 
.SS "pthread_t recv_tid"
Globales útiles sobre la conexión del cliente con el servidor 
.SS "pthread_t sendf_tid"

.SS "int sockfd_user = -1"
descriptor con el socket abierto con el servidor 
.SS "char* stream"

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code\&.
